class_name HFScreenManager
extends Node
## Screen manager class, implemented as a state machine with [HFScreenLoader]
##
## Screen manager that handles the change between any number of [HFScreenLoader]
## using [member HFScreenLoader.screen_id] with an editable autogenerated
## screens constants file and signal callbacks.
## Neither this class nor [HFScreenLoader] would work if a [HFScreenConstants]
## class doesn't exists anywhere in the project.

## Emitted after the screen has changed to a new one
signal screen_changed(screen_id: int)

## Starting [HFScreenLoader] node. It has to be an existing node on the tree,
## but it doesn't need to be a node on [param screens] if it's meant to be
## used only once.
@export var starting_screen: HFScreenLoader
## Array of nodes pointing to instances of [HFScreenLoader] that become part
## of the screens state machine.
@export var screens: Array[HFScreenLoader]

# Internal screens cache for fast data loading
var _screens_map = {}
# Reference to the currently active screen
var _current_screen: HFScreenLoader = null


func _ready() -> void:
	# At runtime, initializes the private map of loaded screens and
	# triggers the first screen if it exists
	_screens_map = {}
	for screen in screens:
		_screens_map[screen.screen_id] = screen
	if starting_screen != null:
		_change_screen.call_deferred(
			starting_screen.screen_id
		)


# Private change screen method. [param screen_id] refers to the id associated with
# the respective [HFScreenLoader], and must be both a valid id and it must refer to an existing
# screen loaded via [member HFScreenLoaderManager.screens]. Does nothing if the [param screen_id]
# doesn't exist and launches an error.
func _change_screen(screen_id: int, value = null) -> void:
	if !_screens_map.has(screen_id):
		HFLog.e("Screen with id %s does not exist!" % screen_id)
		return
	
	# First, clean up the current screen if it exists.
	if _current_screen != null:
		_current_screen.exit()
		if _current_screen.change_screen.is_connected(_change_screen):
			_current_screen.change_screen.disconnect(_change_screen)
		if _current_screen.request_preload_screen.is_connected(_on_request_preload_screen):
			_current_screen.request_preload_screen.disconnect(_on_request_preload_screen)
	# Get the reference and load it
	_current_screen = _screens_map[screen_id]
	if !_current_screen.change_screen.is_connected(_change_screen):
		_current_screen.change_screen.connect(_change_screen)
	if !_current_screen.request_preload_screen.is_connected(_on_request_preload_screen):
		_current_screen.request_preload_screen.connect(_on_request_preload_screen)
	# Then initialize it and emit a signal
	_current_screen.enter(value)
	screen_changed.emit(screen_id)


# Private preload request handling method. It calls the [param screen_id] to preload, and
# calls the [param confirmation_callback] if not null with the screen path.
func _on_request_preload_screen(
	screen_id: int,
	confirmation_callback: Callable
) -> void:
	if !_screens_map.has(screen_id):
		HFLog.e("Screen with id %s does not exist!" % screen_id)
		return
	
	var screen_loader: HFScreenLoader = _screens_map[screen_id]
	confirmation_callback.call(screen_loader.preload_screen())
