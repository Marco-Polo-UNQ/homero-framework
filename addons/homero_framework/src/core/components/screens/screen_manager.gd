@tool
class_name HFScreenManager
extends Node
## Screen manager class, implemented as a state machine with [HFScreenLoader]
##
## Screen manager that handles the change between any number of [HFScreenLoader]
## using [member HFScreenLoader.screen_id] with an autogenerated screens constants made with
## [method HFFilegenUtils.check_class_file_exists_or_create] and signal callbacks.
## Neither this class nor [HFScreenLoader] would work if a [HFScreenConstants] class doesn't
## exists anywhere in the project.

## Emitted after the screen has changed to a new one
signal screen_changed(screen_id: int)

## Starting [HFScreenLoader] node. It has to be an existing node on the tree,
## but it doesn't need to be a node on [param screens] if it's meant to be
## used only once.
@export var starting_screen: HFScreenLoader
## Array of nodes pointing to instances of [HFScreenLoader] on the tree.
@export var screens: Array[HFScreenLoader]

var _screens_map = {}
var _current_screen: HFScreenLoader = null


func _ready() -> void:
	## Checks if the code is evaluated on the Editor or at runtime.
	if Engine.is_editor_hint():
		# On the editor, checks if the [HFScreenConstants] utility class
		# exists somewhere, and if not, creates a new file with the
		# aforementioned path and placeholder code.
		_check_class_file_exists_or_create(
			"HFScreenLoaderConstants",
			"res://screens_constants.gd",
			_get_default_screen_constants_content()
		)
	else:
		## At runtime, initializes the private map of loaded screens and
		## triggers the first screen if it exists
		_screens_map = {}
		for screen in screens:
			_screens_map[screen.get("screen_id")] = screen
		if starting_screen != null:
			call_deferred(
				"_change_screen",
				starting_screen.get("screen_id")
			)


## Private change screen method. [param screen_id] refers to the id associated with
## the respective [HFScreenLoader], and must be both a valid id and it must refer to an existing
## screen loaded via [member HFScreenLoaderManager.screens]. Does nothing if the [param screen_id]
## doesn't exists and launches an error.
func _change_screen(screen_id: int, value = null) -> void:
	if !_screens_map.has(screen_id):
		HFLog.e("Screen with id %s does not exist!" % screen_id)
		return
	
	## First, clean up the current screen if it exists.
	if _current_screen != null:
		_current_screen.exit()
		if _current_screen.change_screen.is_connected(_change_screen):
			_current_screen.change_screen.disconnect(_change_screen)
	## Get the reference and load it
	_current_screen = _screens_map[screen_id]
	if !_current_screen.change_screen.is_connected(_change_screen):
		_current_screen.change_screen.connect(_change_screen)
	## Then initialize it and emit a signal
	_current_screen.enter(value)
	screen_changed.emit(screen_id)


# Utils function that checks the existence of a user-defined class, and if it doesn't exist
# it creates a new file in a path with a determined content.
func _check_class_file_exists_or_create(
		class_p: String,
		file_path: String,
		content: String = _get_default_screen_constants_content()
	) -> void:
		if !ClassDB.class_exists(class_p):
			if !FileAccess.file_exists(file_path):
				var file = FileAccess.open(file_path, FileAccess.WRITE)
				file.store_line(content)


# Returns the default content of the script containing the HFScreenConstants data
func _get_default_screen_constants_content() -> String:
	return "class_name HFScreenConstants\n" +\
				"extends Object\n\n" +\
				"## Custom screen constants class to be used with [HFScreenManager] and [HFScreenLoader]\n\n" +\
				"## Custom enum used for static references to [HFScreenLoader], to be used with [member HFScreenLoader.screen_id].\n" +\
				"## Usage:\n" +\
				"## [codeblock]\n" +\
				"## enum SCREENS {\n" +\
				"##     LOADING,\n" +\
				"##     SCREEN1,\n" +\
				"##     SCREEN2\n" +\
				"##     }\n" +\
				"## [/codeblock]\n" +\
				"enum SCREENS {\n" +\
				"	DEFAULT\n" +\
				"}"
